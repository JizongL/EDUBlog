---
layout: post
title: thinkful ei week 8
date: 2019-04-01 9:47
categories: Thinkful
tags: react javascript review
---

## Database

[postgreSQL cheatSheet](https://www.databaselabs.io/blog/img/Postgres-Cheat-Sheet.pdf)


ACID(Atomicity, Consistency, Isolation, Durability)


TEXT (tradtionally, use less TEXT possible, but postgres is more tolerant with TEXT)
VARCHAR(x)
CHARACTER(x)

`\dt`
see all tables in a database.

`psql -U postgres -d postgres -f demo-shopping.sql`

### Install
```
brew update
brew install postgresql
```

change timezone to UTC in `postgresql.conf`

start the the database server
```
pg_ctl -D /usr/local/var/postgres start
```

Note: we can also use the command `brew services start postgresql` which looks cleaner. The problem is, brew services aren't available on every machine!

check postgres version
```
postgres -V
```

stop the server
```
pg_ctl -D /usr/local/var/postgres start
```


The -D option specifies the location of the database storage area and is required to start and stop the server. To avoid having to specify it each time you can set the environment variable PGDATA on the machine.

```
code ~/.bash_profile
```

add the following

```
export PGDATA=/usr/local/var/postgres
```

save and close

```
source ~/.bash_profile
```
check the environment is setup
```
echo $PGDATA
```

now restart the server

```
pg_ctl start
```


use the psql shell

```
psql
```

`psql --help`


We want PostgreSQL to instead use the database it created for us, postgres, not a database with the same name as the default system username!

```
psql postgres
```

the command `\l` to list the databases on the server

the command `\conninfo` to see which database and user you're connected as

the command `\du` to list the users on the server

and then `\q` to quit.

stop the server

```
pg_ctl stop
```

instead of specifying the database when we open PSQL by using psql postgres, we can override the default username that PSQL attempts to use. If we change this default username to postgres, then PSQL will attempt to connect to the username and database combination of postgres postgres.


create an user
```
createuser -Pw --interactive
```

Type postgres for the name of the "role" to add. Just press return (enter) for no password. Then select y for so that this user is a super user.

Next, we'll need to specify that this user is to be the default user for PSQL

```
code /.bash_profile
```

add the following

```
export PGUSER=postgres
```

run
```
source ~/.bash_profile
```
Now you should be able to connect to psql without needing to specify either database or username as it will use postgres for both.

[postgreSQL wiki](https://wiki.postgresql.org/wiki/PostgreSQL_Clients)


[create role wiki](https://www.postgresql.org/docs/11/sql-createrole.html)

### create database
[create database wiki](https://www.postgresql.org/docs/11/manage-ag-templatedbs.html)



use `UNIQUE` to ensure all titles are unique.
`ALTER TABLE articles ADD COLUMN title TEXT UNIQUE NOT NULL;`


copy files into database

first create a database.

`CREATE DATABASE inventory`
`\c inventory`

```
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  name TEXT,
  aisle TEXT,
  department TEXT,
  price NUMERIC
);
```

`inventory=> \copy products FROM '~/path/to/file/products.csv' WITH DELIMITER ',' CSV;`

COPY 49688




```
postgres=# \c tax_returns
You are now connected to database "tax_returns" as user "YOUR_USERNAME".
tax_returns=#
```

### DBeaver
[download](https://dbeaver.io/download/)


`INTEGER` `TEXT` `TIMESTAMP DEFAULT now()`

`KEY GENERATED BY DEFAULT AS IDENTITY`

`CREATE TYPE department AS ENUM`

`CREATE TABLE IF NOT EXISTS name-of-table( )`

`DROP TYPE IF EXISTS department`



### Knex

[flowchart of database workflow](https://www.lucidchart.com/documents/view/38a65093-86c0-4824-99cf-843a81376ddb)

setup connection with Knex scheme
`client:pg`
`connection:'postgresql://userame:password@example.com:port-number/db'`



`ILIKE` is case insensitive, for searching item.

```
require('dotenv').config()

```

building query

`knexInstance.from('amazong_products');`

`knexInstance('amazong-products')`

`.debug()`
return detail of the connection


different wasy to handle where.
`.where('id',28')`
`.where('id','=',28)`
`.where(({'id':28}))`

`.where`
`.andWhere`
`.orWhere`


to select from column

`knexInstance('amzong-products').select('*');`

`.toQuery` get real SQL query
e.g
`knexInstance('amzong-products').select('*').toQuery;`

promise like object

`then`,`catch`,`finally`,`.select()`,`.from()`,`.toQuery()`

with a callback function

```
knexInstance.from('amazong-products').select('*')
    .then(result=>{
        console.log(result)
        })
```
translate SQL to Knex language

```
SELECT product_id,name, price, category
FROM amazong_products
WHERE name = 'Point of view gun'
```
to knex

```
knexInstance
    .select('product_id','name','price','category')
    .from('amazong_products')
    .where({name:'Point of view gun'})
    .then(result=>{
        console.log(result)
        })
```
use `.first` only select first element.

`select "product_id", "name", "price", "category" from "amazong_products" where "name" = 'Point of view gun' limit 1`

`limit 1` is translated from `.first()`



ILIKE is case insensistive

```javascript
function searchByProduceName(searchTerm){
  knexInstance
  .select('product_id','name','price','category')  
  .from('amazong_products')
  .where('name','ILIKE',`%${searchTerm}%`)
  .then(result=>{
    console.log(result)
  })
}
```


### paginating
```
SELECT product_id, name, price, category FROM amazong_products
LIMIT 10
OFFSET 0;
```

`OFFSET = 10` is one page. because `LIMIT` is set to 10.

Set up pagination function with knex

```
function paginateProducts(page){
    const productsPerPage = 10
    const offset = productsPerPage*(page-1)
    knexInstance
        .select('product_id','name','price',category)
        .from('amazong_products')
        .limit(productPerPage)  
        .offset(offset)  
        .then(result=>{
            console.log(result)
            })
}
paginateProducts(2)
```

### filter
use `.whereNotNull()`
```
SELECT product_id, name, price,category
 FROM amazong_products
 WHERE image IS NOT NULL;
```

translates into knex

```
function getProductWithImages(){
    knexInstance
        .select('product_id','name','price','category','image')
        .from('amazong_products')
        .whereNotNull('image')
        .then(result=>{
            console.log(result)
            })
}

getProductWithImages()
```

### count items

use `count()`

SQL code
```
SELECT video_name, region, count(date_viewed) AS views
FROM whopipe_video_views
WHERE date_viewed > (now()-'30 days'::INTERVAL)
GROUP BY video_name, region
ORDER BY region ASC,views DESC
```
ranslated into javascript

```
function mostPopularVideosForDays(days){
    knexInstance
        .select('video_name','region')
        .count('date_viewed AS views')
        .where(
            'date_viewed',
            '>',
            knexInstance.raw(`now()-'?? days'::INTERVAL`,days)
            )
            .from('whopipe_video_views')
            .groupBy('video_name','region')
            .orderBy([
                {column:'region',order:'ASC'},
                {column:'views',order:'DESC'},
                ])
                .then(result=>{
                    console.log(result)
                    })
}

mostPopularVideosForDays(30)

```

pass raw SQL as a string.
`.raw()`

prepared statement is a security measure to prevent SQL injection.
`??` specify user input. (see code above)


create interval
`‘30 days’::interval`
usage e.g.
`now()-‘30 days’::interval`

*note*

study `cast` sql later



### Building Services

best practices

"Don't repeat yourself" (DRY) for using functions
"Separation of concerns" (SOC) for organizing functions
"Modularisation and layering" to structure files
"Encapsulation" for bundling methods together that operate on the same data

short for
DRY
SOC

CRUD stands for:
Create
Read
Update
Delete

A circle of requires is called a dependency cycle and is analogous to an infinite loop.

### TDD
One approach to development is called "test-driven development" (TDD). TDD is a 3 part process for writing tests:

RED: Write a test and see it fail.
GREEN: Write implementation code to make the test pass.
REFACTOR: Refactor both the test code and implementation code.



knex's `insert` method

```javascript
knexInstance('table_name').insert([{ name: 'foo' }, { name: 'bar' }])
// or
knexInstance.into('table_name').insert([{ name: 'foo' }, { name: 'bar' }])
```

close all the connection after testing
`knexInstance.destroy()`



### date time difference issue with PostgreSQL

```javascript
return ArticleService.insertArticle(db, newArticle)
  .then(actual => {
    expect(actual).to.eql({
      id: 1,
      title: newArticle.title,
      content: newArticle.content,
-        // date_published: newArticle.date_published,
+        date_published: new Date(newArticle.date_published),
    })
  })
})

```

Note, the context function is a synonym for the describe function. We can interchange them with no functional difference. The reason to use context here is for the semantics of reading the test code to see that we're setting a "context" of state for a group of tests.


### returning after inserting
```javascript
insertArticle(knex,newArticle){
    return knex
      .insert(newArticle)
      .into('blogful_articles')
      .returning('*')
  }
```

[cloudcraft](https://cloudcraft.co/app)

relations and joining

[SQL Relationship](https://www.lucidchart.com/documents/view/275bb88c-c279-4336-a586-f6592e2035b1/0)
[SQL Relationship github code](https://gist.github.com/cklanac/6b41fe2280b47cfe94efb27ffa6e2d31) from instructor



order of tables created is important
`REFERENCES(users(id))`
